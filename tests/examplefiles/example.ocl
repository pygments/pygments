-- this file contains some OCL constraints,
-- mainly from the UML Semantics guide v1.3.
-- every definition starts with a context declaration,
-- and ends before the next context declaration

-- help: give an explanation message

context ActionState
-- [1] An action state has a non-empty entry action.
inv: self.entry->size > 0

context ActionState
-- [2] An action state does not have an internal transition, exit action, or a do activity.
inv: self.internalTransition->size = 0 and self.exit->size = 0 and \
		self.doActivity->size = 0

context ActionState
-- [3] Transitions originating from an action state have no trigger event.
inv: self.outgoing->forAll(t | t.trigger->size = 0)

context ActivityGraph
-- [1] An ActivityGraph specifies the dynamics of (i) a Package, or (ii) a Classifier (including UseCase), or (iii) a BehavioralFeature.
inv: (self.context.oclIsTypeOf(Package) xor \
	self.context.oclIsKindOf(Classifier) xor \
	self.context.oclIsKindOf(BehavioralFeature))

context Actor
-- [1] Actors can only have Associations to UseCases, Subsystems, and Classes and these Associations are binary.
inv: self.associations->forAll(a | \
		a.connection->size = 2 and \
		a.allConnections->exists(r | r.type.oclIsKindOf(Actor)) and \
		a.allConnections->exists(r | \
		r.type.oclIsKindOf(UseCase) or \
		r.type.oclIsKindOf(Subsystem) or \
		r.type.oclIsKindOf(Class)))

context Actor
-- [2] Actors cannot contain any Classifiers.
inv: self.contents->isEmpty

context Association
	-- the AssociationEnds must have a unique name within the Association.
	inv: self.allConnections->forAll(r1, r2 | r1.name = r2.name implies r1= r2)

context Association
	-- at most one AssociationEnd may be an aggregation or composition.
	inv: self.allConnections->select(ae | ae.aggregation <> #none)->size <= 1

context Association
	-- if an Association has three or more AssociationEnds, then no AssociationEnd may be an aggregation or composition.
	inv: self.allConnections->size >= 3 implies \
				  self.allConnections->forAll(ae | ae.aggregation = #none)

context Association
	-- the connected Classifiers of the AssociationEnds should be included in the Namespace of the Association.
	inv: self.allConnections->forAll(r | \
		self.namespace.allContents->includes(r.type))

context Association::allConnections():Set(AssociationEnd)
	-- the operation allConnections results in the set of all AssociationEnds of the Association.
	asl: self.connection->asSet
	post: result = self.connection->asSet

context AssociationClass
	-- the names of the AssociationEnds and the StructuralFeatures do not overlap.
	inv: self.allConnections->forAll(ar | \
		self.allFeatures->forAll(f | \
			f.oclIsKindOf(structuralFeature) implies ar.name <> f.name)) \

context AssociationClass
	-- an AssociationClass cannot be defined between itself and something else.
	inv: self.allConnections->forAll(ar | ar.type <> self)

context AssociationClass::allConnections():Set(AssociationEnd)
	-- the operation allConnections results in the set of all AssociationEnds of the AssociationClass, including all connections defined by its parent (transitive closure).
	asl: self.connection->union(self.parent->select(s | s.oclIsKindOf(Association))->collect(a:Association|a.allConnections))->asSet
	post: result = self.connection->union(self.parent->select(s | s.oclIsKindOf(Association))->collect(a |a.oclAsType(Association).allConnections))->asSet

context AssociationEnd
	-- the Classifier of an AssociationEnd cannot be an Interface or a DataType if the association is navigable away from that end.
	inv: (self.type.oclIsKindOf(Interface) or \
	self.type.oclIsKindOf(DataType)) implies \
		self.association.connection->select(ae | \
						       ae <> self)->forAll(ae | ae.isNavigable = false)

context AssociationEnd
	-- an Instance may not belong by composition to more than one composite Instance.
	inv: self.aggregation = #composite implies self.multiplicity.max < 1

context AssociationEndRole
-- [1] The type of the ClassifierRole must conform to the type of the base AssociationEnd.
inv: self.type.oclAsType(ClassifierRole).base = self.base.type \
	or \
	self.type.oclAsType(ClassifierRole).base.allParents->includes (self.base.type)

context AssociationEndRole
-- [2] The type must be a kind of ClassifierRole.
inv: self.type.oclIsKindOf (ClassifierRole)

context AssociationEndRole
-- [3] The qualifiers used in the AssociationEndRole must be a subset of those in the base AssociationEnd.
inv: self.base.qualifier->includesAll (self.availableQualifier)

context AssociationEndRole
-- [4] In a collaboration an association may only be used for traversal if it is allowed by the base association.
inv: self.isNavigable implies self.base.isNavigable

context AssociationRole
-- [1] The AssociationEndRoles must conform to the AssociationEnds of the base Association.
-- [FP] connection association is not {ordered} in the metamodel !
inv: Sequence{ 1..(self.connection->size) }->forAll (index | \
		self.connection->at(index).base = \
		self.base.connection->at(index))

context AssociationRole
-- [2] The endpoints must be a kind of AssociationEndRoles.
inv: self.connection->forAll( r | r.oclIsKindOf (AssociationEndRole))

context AttributeLink
-- The type of the Instance must match the type of the Attribute.
inv: self.value.classifier->union ( \
		self.value.classifier.allParents)->includes ( \
						self.attribute.type)
context BehavioralFeature
	-- all Parameters should have a unique name.
	inv: self.parameter->forAll(p1,p2 | p1.name = p2.name implies p1 = p2)

context BehavioralFeature
	-- the type of the Parameters should be included in the Namespace of the Classifier.
	inv: self.parameter->forAll(p | \
				 self.owner.namespace.allContents->includes(p.type))

context BehavioralFeature::hasSameSignature(b:BehavioralFeature):Boolean
	-- the operation hasSameSignature checks if the argument has the same signature as the instance itself
	asl: (self.name = b.name) and (self.parameter->size = b.parameter->size) and Sequence(Integer){1..(self.parameter->size)}->forAll(index:Integer| b.parameter->at(index).type = self.parameter->at(index).type and b.parameter->at(index).kind = self.parameter->at(index).kind)
	post: result = (self.name = b.name) and (self.parameter->size = b.parameter->size) and Sequence(Integer){1..(self.parameter->size)}->forAll(index:Integer| b.parameter->at(index).type = self.parameter->at(index).type and b.parameter->at(index).kind = self.parameter->at(index).kind)

context BehavioralFeature::matchesSignature(b:BehavioralFeature):Boolean
	-- the operation matchesSignature checks if the argument has a signature that would clash with the signature of the instance itself (and therefore must be unique). Mismatches in kind or any differences in return parameters do not cause a mismatch.
	asl: (self.name = b.name) and (self.parameter->size = b.parameter->size) and Sequence(Integer){1..(self.parameter->size)}->forAll(index:Integer | b.parameter->at(index).type = self.parameter->at(index).type or (b.parameter->at(index).kind = #return and self.parameter->at(index).kind = #return))
	post: result = (self.name = b.name) and (self.parameter->size = b.parameter->size) and Sequence(Integer){1..(self.parameter->size)}->forAll(index:Integer | b.parameter->at(index).type = self.parameter->at(index).type or (b.parameter->at(index).kind = #return and self.parameter->at(index).kind = #return))

context Binding
	-- the argument ModelElement must conform to the parameter ModelElement in a Binding. In an Instantiation it must be of the same kind.
	inv: true

context Binding
	-- a binding has one client and one supplier.
	inv: (self.client->size = 1) and (self.supplier->size = 1)

context Binding
	-- a ModelElement may participate in at most one Binding as a client.
	inv: Binding.allInstances->forAll(b1, b2 | \
					 (b1 <> b2) implies (b1.client <> b2.client))

context CallAction
-- [1] The number of arguments be the same as the number of the Operation.
inv: self.actualArgument->size = self.operation.parameter->size

context CallState
-- [1] The entry action of a call state is a single call action.
inv: self.entry->size = 1 and self.entry.oclIsKindOf(CallAction)

context Class
	-- if a Class is concrete, all the Operations of the Class should have a realizing Method in the full descriptor.
	inv: not self.isAbstract implies self.allOperations->forAll(op| self.allMethods->exists(m | m.specification = op))

context Class
	-- a Class can only contain Classes, Associations, Generalizations, UseCases, Constraints, Dependencies, Collaborations, DataTypes, and Interfaces as a Namespace.
	inv: self.allContents->forAll(c | \
				   c.oclIsKindOf(Class) or \
				   c.oclIsKindOf(Association) or \
				   c.oclIsKindOf(Generalization) or \
				   c.oclIsKindOf(UseCase) or \
				   c.oclIsKindOf(Constraint) or \
				   c.oclIsKindOf(Dependency) or \
				   c.oclIsKindOf(Collaboration) or \
				   c.oclIsKindOf(DataType) or \
				   c.oclIsKindOf(Interface))

context Classifier
	-- no BehavioralFeature of the same kind may match the same signature in a Classifier.
	inv: self.feature->forAll(f,g | \
	( \
	  ( \
	    ( f.oclIsKindOf(Operation) and g.oclIsKindOf(Operation)) or \
	    ( f.oclIsKindOf(Method) and g.oclIsKindOf(Method)) or \
	    ( f.oclIsKindOf(Reception) and g.oclIsKindOf(Reception)) \
	    ) and \
	    f.oclAsType(BehavioralFeature).matchesSignature(g.oclAsType(BehavioralFeature)) \
	    ) \
	    implies f = g)

context Classifier
	-- no Attributes may have the same name within a Classifier.
	inv: self.feature->select(a | a.oclIsKindOf(Attribute))->forAll(p,q | \
			       p.name = q.name implies p = q)

context Classifier
	-- no opposite AssociationEnds may have the same name within a Classifier.
	inv: self.oppositeAssociationEnds->forAll(p, q | p.name = q.name implies p = q)

context Classifier
	-- the name of an Attribute may not be the same as the name of an opposite AssociationEnd or a ModelElement contained in the Classifier.
	inv: self.feature->select(a | a.oclIsKindOf(Attribute))->forAll(a | \
			       not self.allOppositeAssociationEnds->union(self.allContents)->collect(q | q.name)->includes(a.name))

context Classifier
	-- the name of an opposite AssociationEnd may not be the same as the name of an Attribute or a ModelElement contained in the Classifier.
	inv: self.oppositeAssociationEnds->forAll(o | \
					       not self.allAttributes->union(self.allContents)->collect(q| q.name)->includes(o.name))

context Classifier
	-- for each Operation in a specification realized by the Classifier, the Classifier must have a matching Operation.
	inv: self.specification.allOperations->forAll(interOp | \
							 self.allOperations->exists(op | \
							 op.matchesSignature(interOp)))

context Classifier
	-- all of the Generalizations in the range of a Powertype have the same discriminator.
	inv: self.powertypeRange->forAll(g1,g2|g1.discriminator=g2.discriminator)

context Classifier
	-- Discriminator names must be distinct from attribute names and opposite AssociationEnd names.
	inv: self.allDiscriminators->intersection(self.allAttributes.name->union(self.allOppositeAssociationEnds.name))->isEmpty

context Classifier::allFeatures():Set(Feature)
	-- the operation allFeatures results in a Set containing all Features of the Classifier itself and all its inherited Features.
	asl: self.feature->union(self.parent->collect(c | c.oclAsType(Classifier).allFeatures))->asSet
	post: result = self.feature->union(self.parent->collect(c | c.oclAsType(Classifier).allFeatures))->asSet

context Classifier::allOperations():Set(Operation)
	-- the operation allOperations results in a Set containing all Operations of the Classifier itself and all its inherited Operations.
	asl: self.allFeatures->select(f| f.oclIsKindOf(Operation))
	post: result = self.allFeatures->select(f| f.oclIsKindOf(Operation))

context Classifier::allMethods():Set(Method)
	-- the operation allMethods results in a Set containing all Methods of the Classifier itself and all its inherited Methods.
	asl: self.allFeatures->select(f | f.oclIsKindOf(Method))
	post: result = self.allFeatures->select(f | f.oclIsKindOf(Method))

context Classifier::allAttributes():Set(Attribute)
	-- the operation allAttributes results in a Set containing all Attributes of the Classifier itself and all its inherited Attributes.
	asl: self.allFeatures->select(f | f.oclIsKindOf(Attribute))
	post: result = self.allFeatures->select(f | f.oclIsKindOf(Attribute))

context Classifier::associations():Set(Association)
	-- the operations associations results in a Set containing all Associations of the Classifier itself
	asl: self.associationEnd.association
	post: result = self.associationEnd.association

context Classifier::allAssociations:Set(Association)
	-- the operation allAssociations results in a Set containing all Associations of the Classifier itself and all its inherited Associations.
	asl: self.associations->union(self.parent->collect(g | g.oclAsType(Classifier).allAssociations))->asSet
	post: result = self.associations->union(self.parent->collect(g | g.oclAsType(Classifier).allAssociations))->asSet

context Classifier::oppositeAssociationEnds:Set(AssociationEnd)
	-- results in a set of all AssociationEnds that are opposite to the Classifier
	asl: self.associations->select(a|a.connection->select(ae | \
	      ae.type = self)->size = 1)->collect(a | \
	      a.connection->select(ae | ae.type <> self))->union \
	      ( \
	      self.associations->select(a | a.connection->select(ae | \
	      ae.type = self).size <> 1)->collect(a | \
	      a.connection))->asSet
	post: result = self.associations->select(a|a.connection->select(ae | \
	      ae.type = self)->size = 1)->collect(a | \
	      a.connection->select(ae | ae.type <> self))->union \
	      ( \
	      self.associations->select(a | a.connection->select(ae | \
	      ae.type = self).size <> 1)->collect(a | \
	      a.connection))->asSet

context Classifier::allOppositeAssociationEnds:Set(AssociationEnd)
	-- the operation allOppositeAssociationEnds results in a set of all AssociationEnds, including the inherited ones, that are opposite to the Classifier.
	asl: self.oppositeAssociationEnds->union(self.parent->collect(g | g.oclAsType(Classifier).allOppositeAssociationEnds))->asSet
	post: result = self.oppositeAssociationEnds->union(self.parent->collect(g | g.oclAsType(Classifier).allOppositeAssociationEnds))->asSet

context Classifier::specification:Set(Classifier)
	-- the operation specification yields the set of Classifiers that the current Classifier realizes.
	asl: self.clientDependency->select(d | \
	      d.oclIsKindOf(Abstraction) \
	      and d.stereotype.name = 'realization').supplier \
	      ->collect(g | g.oclAsType(Classifier))->asSet
	post: result = self.clientDependency->select(d | \
	      d.oclIsKindOf(Abstraction) \
	      and d.stereotype.name = 'realization').supplier \
	      ->collect(g | g.oclAsType(Classifier))->asSet

context Classifier::allContents:Set(ModelElement)
	-- the operation allContents returns a Set containing all ModelElements contained in the Classifier together with the contents inherited from its parents.
	asl: self.contents->union(self.parent->collect(g | g.oclAsType(Classifier).allContents->select(e | \
	      e.elementOwnership.visibility = #public or \
	      e.elementOwnership.visibility = #protected)))
	post: result = self.contents->union(self.parent->collect(g | g.oclAsType(Classifier).allContents->select(e | \
	      e.elementOwnership.visibility = #public or \
	      e.elementOwnership.visibility = #protected)))

context Classifier::allDiscriminators:Set(Name)
	-- the operation allDiscriminators results in a Set containing all Discriminators of the Generalizations from which the Classifier is descended itself and all its inherited Features.
	asl: self.generalization.discriminator->union(self.parent->collect(g | g.oclAsType(Classifier).allDiscriminators))
	post: result = self.generalization.discriminator->union(self.parent->collect(g | g.oclAsType(Classifier).allDiscriminators))

context ClassifierRole
-- [1] The AssociationRoles connected to the ClassifierRole must match a subset of the Associations connected to the base Classifiers.
inv: self.allAssociations->forAll( ar | \
	self.base.allAssociations->exists ( a | ar = a ) )

context ClassifierRole
-- [2] The Features and contents of the ClassifierRole must be subsets of those of the base Classifiers.
inv: self.base.allFeatures->includesAll (self.allAvailableFeatures) \
	and \
	self.base.allContents->includesAll (self.allAvailableContents)

context ClassifierRole
-- [3] A ClassifierRole does not have any Features of its own.
inv: self.allFeatures->isEmpty

context ClassifierRole::allAvailableFeatures():Set(Feature)
-- [1] The operation allAvailableFeatures results in the set of all Features contained in the ClassifierRole together with those contained in the parents.
post: result = self.availableFeature->union(self.parent->collect(cr | cr.oclAsType(ClassifierRole).allAvailableFeatures))

context ClassifierRole::allAvailableContents:Set(ModelElement)
-- [2] The operation allAvailableContents results in the set of all ModelElements contained in the ClassifierRole together with those contained in the parents.
post: result = self.availableContents->union(self.parent->collect(cr | cr.oclAsType(ClassifierRole).allAvailableContents))

context Collaboration
-- [1] All Classifiers and Associations of the ClassifierRoles and AssociationRoles in the Collaboration must be included in the namespace owning the Collaboration.
inv: self.allContents->forAll ( e | \
		(e.oclIsKindOf (ClassifierRole) implies \
		self.namespace.allContents->includes ( \
		e.oclAsType(ClassifierRole).base) ) \
		and \
		(e.oclIsKindOf (AssociationRole) implies \
		self.namespace.allContents->includes ( \
		e.oclAsType(AssociationRole).base) ))

context Collaboration
-- [2] All the constraining ModelElements must be included in the namespace owning the Collaboration.
inv: self.constrainingElement->forAll ( ce | \
		self.namespace.allContents->includes (ce) )

context Collaboration
-- [3] If a ClassifierRole or an AssociationRole does not have a name then it should be the only one with a particular base.
inv: self.allContents->forAll ( p | \
		(p.oclIsKindOf (ClassifierRole) implies \
		p.name = '' implies \
		self.allContents->forAll ( q | \
		q.oclIsKindOf(ClassifierRole) implies \
		(p.oclAsType(ClassifierRole).base = \
		q.oclAsType(ClassifierRole).base implies \
		p = q) ) ) \
			and \
		(p.oclIsKindOf (AssociationRole) implies \
		p.name = '' implies \
		self.allContents->forAll ( q | \
		q.oclIsKindOf(AssociationRole) implies \
		(p.oclAsType(AssociationRole).base = \
		q.oclAsType(AssociationRole).base implies \
		p = q) ) ) \
		)

context Collaboration
-- [4] A Collaboration may only contain ClassifierRoles and AssociationRoles, and the Generalizations and the Constraints between them.
inv: self.allContents->forAll ( p | \
	p.oclIsKindOf (ClassifierRole) or \
	p.oclIsKindOf (AssociationRole) or \
	p.oclIsKindOf (Generalization) or \
	p.oclIsKindOf (Constraint) )

context Collaboration
-- [5] A role with the same name as one of the roles in a parent of the Collaboration must be a child (a specialization) of that role.
inv: self.contents->forAll ( c | \
			   	self.parent->collect(g : GeneralizableElement | \
				       g.oclAsType(Collaboration).allContents)->forAll ( p | \
				       c.name = p.name implies c.allParents->includes(p) ))

context Collaboration::allContents:Set(ModelElement)
-- [1] The operation allContents results in the set of all ModelElements contained in the Collaboration together with those contained in the parents except those that have been specialized.
post: result = self.contents->union ( \
				  self.parent->collect(g | \
					g.oclAsType(Collaboration).allContents)->reject ( e | \
						self.contents.name->includes(e.name) ))

context Component
	-- a Component may only contain other Components
	inv: self.allContents->forAll(c | c.oclIsKindOf(Component))

context Component
	-- a Component may only implement DataTypes, Interfaces, Classes, Associations, Dependencies, Constraints, Signals, DataValues and Objects.
	inv: self.allResidentElements->forAll(re | \
					    re.oclIsKindOf(DataType) or \
					    re.oclIsKindOf(Interface) or \
					    re.oclIsKindOf(Class) or \
					    re.oclIsKindOf(Association) or \
					    re.oclIsKindOf(Dependency) or \
					    re.oclIsKindOf(Constraint) or \
					    re.oclIsKindOf(Signal) or \
					    re.oclIsKindOf(DataValue) or \
					    re.oclIsKindOf(Object))

context Component::allResidentElements:Set(ModelElement)
	-- the operation allResidentElements results in a set containing all ModelElements resident in a Component or one of its ancestors.
	asl: self.resident->union(self.parent->collect(g | g.oclAsType(Component).allResidentElements)->select(re | \
	      re.elementResidence.visibility = #public or \
	      re.elementResidence.visibility = #protected))
	post: result = self.resident->union(self.parent->collect(g | g.oclAsType(Component).allResidentElements)->select(re | \
	      re.elementResidence.visibility = #public or \
	      re.elementResidence.visibility = #protected))

context Component::allVisibleElements:Set(ModelElement)
	-- the operation allVisibleElements results in a set containing all ModelElements visible outside the Component.
	asl: self.allContents->select(e | \
		     e.elementOwnership.visibility = #public)->union( \
						   self.allResidentElements->select(re | \
						   re.elementResidence.visibility = #public))
	post: result = self.allContents->select(e | \
		     e.elementOwnership.visibility = #public)->union( \
						   self.allResidentElements->select(re | \
						   re.elementResidence.visibility = #public))

context ComponentInstance
-- [1] A ComponentInstance originates from exactly one Component.
inv: self.classifier->size = 1 \
		and self.classifier.oclIsKindOf (Component)

context CompositeState
-- [1] A composite state can have at most one initial vertex.
inv: self.subvertex->select (v | v.oclIsKindOf(Pseudostate))-> \
	select(p | p.oclAsType(Pseudostate).kind = #initial)->size <= 1

context CompositeState
-- [2] A composite state can have at most one deep history vertex.
inv: self.subvertex->select (v | v.oclIsKindOf(Pseudostate))-> \
     select(p | p.oclAsType(Pseudostate).kind = #deepHistory)->size <= 1

context CompositeState
-- [3] A composite state can have at most one shallow history vertex.
inv: self.subvertex->select(v | v.oclIsKindOf(Pseudostate))-> \
	select(p | p.oclAsType(Pseudostate).kind = #shallowHistory)->size <= 1

context CompositeState
-- [4] There have to be at least two composite substates in a concurrent composite state.
inv: (self.isConcurrent) implies \
		(self.subvertex->select \
		(v | v.oclIsKindOf(CompositeState))->size >= 2)

context CompositeState
-- [5] A concurrent state can only have composite states as substates.
inv: (self.isConcurrent) implies \
	self.subvertex->forAll(s | s.oclIsKindOf(CompositeState))

context CompositeState
-- [6] The substates of a composite state are part of only that composite state.
inv: self.subvertex->forAll(s | (s.container->size = 1) and \
				(s.container = self))

context Constraint
	-- a Constraint cannot be applied to itself.
	inv: not self.constrainedElement->includes(self)

context Constraint
-- [1] A Constraint attached to a Stereotype must not conflict with Constraints on any inherited Stereotype, or associated with the baseClass.
-- cannot be specified with OCL
inv: true

context Constraint
-- [2] A Constraint attached to a stereotyped ModelElement must not conflict with any constraints on the attached classifying Stereotype, nor with the Class (the baseClass) of the ModelElement.
-- cannot be specified with OCL
inv: true

context Constraint
-- [3] A Constraint attached to a Stereotype will apply to all ModelElements classified by that Stereotype and must not conflict with any constraints on the attached classifying Stereotype, nor with the Class (the baseClass) of the ModelElement.
-- cannot be specified with OCL
inv: true

context CreateAction
-- [1] A CreateAction does not have a target expression.
inv: self.target->isEmpty

context DataType
	-- a DataType can only contain Operations, which all must be queries.
	inv: self.allFeatures->forAll(f | \
	     f.oclIsKindOf(Operation) and \
	     f.oclAsType(Operation).isQuery)

context DataType
	-- a DataType cannot contain any other ModelElements.
	inv: self.allContents->isEmpty

context DataValue
-- [1] A DataValue originates from exactly one Classifier, which is a DataType.
inv: (self.classifier->size = 1) \
		and self.classifier.oclIsKindOf(DataType)

context DataValue
-- [2] A DataValue has no AttributeLinks.
inv: self.slot->isEmpty

context DestroyAction
-- [1] A DestroyAction should not have arguments.
inv: self.actualArgument->size = 0

context Extend
-- [1] The referenced ExtensionPoints must be included in set of ExtensionPoint in the target UseCase.
inv: self.base.allExtensionPoints -> includesAll (self.location)

context ExtensionPoint
-- [1] The name must not be the empty string.
inv: not (self.name = '')

context FinalState
-- [1] A final state cannot have any outgoing transitions.
inv: self.outgoing->size = 0

context GeneralizableElement
	-- a root cannot have any Generalizations.
	inv: self.isRoot implies self.generalization->isEmpty

context GeneralizableElement
	-- no GeneralizableElement can have a parent Generalization to an element which is a Leaf.
	inv: self.parent->forAll(s | not s.isLeaf)

context GeneralizableElement
	-- circular inheritance is not allowed.
	inv: not self.allParents->includes(self)

context GeneralizableElement
	-- the parent must be included in the Namespace of the GeneralizableElement.
	inv: self.generalization->forAll(g | \
					   self.namespace.allContents->includes(g.parent))

context GeneralizableElement::parent:Set(GeneralizableElement)
	-- the operation parent returns a set containing all direct parents
	asl: self.generalization.parent
	post: result = self.generalization.parent

context GeneralizableElement::allParents:Set(GeneralizableElement)
	-- the operation allParents returns a set containing all the GeneralizableElements inherited by this GeneralizableElement (the transitive closure), excluding the GeneralizableElement itself.
	asl: self.parent->union(self.parent.allParents->asSet)
	post: result = self.parent->union(self.parent.allParents->asSet)

context Generalization
	-- a GeneralizableElement may only be a child of a GeneralizableElement of the same kind.
	inv: true

context Guard
-- [1] A guard should not have side effects.
inv: self.transition->stateMachine->notEmpty implies \
		(self.transition.stateMachine->context = \
		self.transition.stateMachine->context@pre)

context Instance
-- [1] The AttributeLinks match the declarations in the Classifiers.
inv: self.slot->forAll ( al | \
		self.classifier->exists ( c | \
			c.allAttributes->includes ( al.attribute ) ) )

context Instance
-- [2] The Links matches the declarations in the Classifiers.
inv: self.allLinks->forAll ( l | \
				self.classifier->exists ( c | \
				c.allAssociations->includes ( l.association )))

context Instance
-- [3] If two Operations have the same signature they must be the same.
inv: self.classifier->forAll ( c1, c2 | \
			c1.allOperations->forAll ( op1 | \
			c2.allOperations->forAll ( op2 | \
			op1.hasSameSignature (op2) implies op1 = op2 ) ) )

context Instance
-- [4] There are no name conflicts between the AttributeLinks and opposite LinkEnds.
inv: self.slot->forAll( al | \
	not self.allOppositeLinkEnds->exists( le | le.name = al.name ) ) \
		and self.allOppositeLinkEnds->forAll( le | \
	not self.slot->exists( al | le.name = al.name ) )

context Instance
-- [5] For each Association in which an Instance is involved, the number of opposite LinkEnds must match the multiplicity of the AssociationEnd.
inv: self.classifier.allOppositeAssociationEnds->forAll ( ae | \
		ae.multiplicity.multiplicityRange->exists ( mr | \
		self.selectedLinkEnds (ae)->size >= mr.lower and \
		(mr.upper = 'unlimited' or \
		(mr.upper <> 'unlimited' and \
		self.selectedLinkEnds (ae)->size <= \
		mr.upper.oclAsType (Integer) ) ) ) )

context Instance
-- [6] The number of associated AttributeLinks must match the multiplicity of the Attribute.
inv: self.classifier.allAttributes->forAll ( a | \
		a.multiplicity.multiplicityRange->exists ( mr | \
		self.selectedAttributeLinks(a)->size >= mr.lower and \
			(mr.upper = 'unlimited' or \
			(mr.upper <> 'unlimited' and \
			self.selectedLinkEnds (a)->size <= \
			mr.upper.oclAsType (Integer) ) ) ) )

context Instance::allLinks:Set(Link)
-- [1] The operation allLinks results in a set containing all Links of the Instance itself.
asl: self.linkEnd.link
post: result = self.linkEnd.link

context Instance::allOppositeLinkEnds:Set(LinkEnd)
-- [2] The operation allOppositeLinkEnds results in a set containing all LinkEnds of Links connected to the Instance with another LinkEnd.
post: result = self.allLinks.connection->select (le | \
						le.instance <> self)

context Instance::selectedLinkEnds(ae:AssociationEnd):Set(LinkEnd)
-- [3] The operation selectedLinkEnds results in a set containing all opposite LinkEnds corresponding to a given AssociationEnd.
post: result = self.allOppositeLinkEnds->select (le | \
						le.associationEnd = ae)

context Instance::selectedAttributeLinks(ae:Attribute):Set(AttributeLink)
-- [4] The operation selectedAttributeLinks results in a set containing all AttributeLinks corresponding to a given Attribute.
post: result = self.slot->select (s | \
				 	s.attribute = ae)
context Interaction
--[1] All Signals being sent must be included in the namespace owning the Collaboration in which the Interaction is defined.
inv: self.message->forAll ( m | \
		m.action.oclIsKindOf(SendAction) implies \
		self.context.namespace.allContents->includes ( \
		m.action->oclAsType (SendAction).signal) )

context Interface
	-- an Interface can only contain Operations.
	inv: self.allFeatures->forAll(f | \
					f.oclIsKindOf(Operation) or f.oclIsKindOf(Reception))

context Interface
	-- an Interface cannot contain any ModelElements.
	inv: self.allContents->isEmpty

context Interface
	-- all Features defined in Interface are public.
	inv: self.allFeatures->forAll(f | f.visibility = #public)

context Link
-- [1] The set of LinkEnds must match the set of AssociationEnds of the Association.
inv: Sequence {1..self.connection->size}->forAll ( i | \
		self.connection->at (i).associationEnd = \
		self.association.connection->at (i) )

context Link
-- [2] There are not two Links of the same Association which connects the same set of Instances in the same way.
inv: self.association.link->forAll ( l | \
		Sequence {1..self.connection->size}->forAll ( i | \
			self.connection->at (i).instance = \
			l.connection->at (i).instance ) \
			implies self = l )

context LinkEnd
-- [1] The type of the Instance must match the type of the AssociationEnd.
inv: self.instance.classifier->union ( \
			self.instance.classifier.allParents)->includes ( \
			self.associationEnd.type)

context LinkObject
-- [1] One of the Classifiers must be the same as the Association.
inv: self.classifier->includes(self.association)

context LinkObject
-- [2] The Association must be a kind of AssociationClass.
inv: self.association.oclIsKindOf(AssociationClass)

context Message
-- [1] The sender and the receiver must participate in the Collaboration which defines the context of the Interaction.
inv: self.interaction.context.ownedElement->includes (self.sender) \
	and \
	self.interaction.context.ownedElement->includes (self.receiver)

context Message
-- [2] The predecessors and the activator must be contained in the same Interaction.
inv: self.predecessor->forAll ( p | p.interaction = self.interaction ) \
	and \
	self.activator.interaction = self.interaction

context Message
-- [3] The predecessors must have the same activator as the Message.
inv: self.allPredecessors->forAll ( p | p.activator = self.activator )

context Message
-- [4] A Message cannot be the predecessor of itself.
inv: not self.allPredecessors->includes (self)

context Message
-- [5] The communicationLink of the Message must be an AssociationRole in the context of the MessageÂ’s Interaction
inv: self.interaction.context.ownedElement->includes ( \
					self.communicationConnection)

context Message
-- [6] The sender and the receiver roles must be connected by the AssociationRole which acts as the communication connection.
inv: self.communicationConnection->size > 0 implies \
		self.communicationConnection.connection->exists (ar | \
			ar.type = self.sender) \
		and \
		self.communicationConnection.connection->exists (ar | \
			ar.type = self.receiver)

context Message::allPredecessors:Set(Message)
-- [1] The operation allPredecessors results in the set of all Messages that precede the current one.
post: result = self.predecessor->union(self.predecessor.allPredecessors)

context Method
	-- if the realized Operation is a query, then so is the Method.
	inv: self.specification->isQuery implies self.isQuery

context Method
	-- the signature of the Method should be the same as the signature of the realized Operation.
	inv: self.hasSameSignature(self.specification)

context Method
	-- the visibility of the Method should be the same as for the realized Operation.
	inv: self.visibility = self.specification.visibility

context Method
	-- the realized Operation must be a feature (possibly inherited) of the same Classifier as the Method.
	inv: self.owner.allOperations->includes(self.specification)

context Method
	-- if the realized Operation has been overriden one or more times in the ancestors of the owner of the Method, then the Method must realize the latest overriding (that is, all other Operations with the same signature must be owned by ancestors of the owner of the realized Operation).
	inv: self.specification.owner.allOperations->includesAll( \
	     (self.owner.allOperations->select(op | \
	     self.hasSameSignature(op))))

context ModelElement::supplier:Set(ModelElement)
	-- the operation supplier results in a Set containing all direct suppliers of the ModelElement.
	asl: self.clientDependency.supplier
	post: result = self.clientDependency.supplier

context ModelElement::allSuppliers:Set(ModelElement)
	-- the operation allSuppliers results in a Set containing all the ModelElements that are suppliers of this ModelElement, including the suppliers of these ModelElements. This is the transitive closure.
	asl: self.supplier->union(self.supplier.allSuppliers)
	post: result = self.supplier->union(self.supplier.allSuppliers)

context ModelElement::model:Set(Model)
	-- the operation model results in the set of Models to which the ModelElement belongs.
	asl: self.namespace.allSurroundingNamespaces->including(self.namespace)->select(ns | \
		     ns.oclIsKindOf(Model))
	post: result = self.namespace.allSurroundingNamespaces->including(self.namespace)->select(ns | \
		 ns.oclIsKindOf(Model))

context ModelElement::isTemplate:Boolean
	-- a ModelElement is a template when it has parameters.
	asl: self.templateParameter->notEmpty
	post: result = self.templateParameter->notEmpty

context ModelElement::isInstantiated:Boolean
	-- a ModelElement is an instantiated template when it is related to a template by a Binding relationship.
	asl: self.clientDependency->select(oclIsKindOf(Binding))->notEmpty
	post: result = self.clientDependency->select(oclIsKindOf(Binding))->notEmpty

context ModelElement::templateArguments:Set(ModelElement)
	-- the templateArguments are the arguments of an instantiated template, which substitute for template parameters.
	asl: self.clientDependency->select(d:Dependency | d.oclIsKindOf(Binding))->collect(b | b.oclAsType(Binding).argument)->asSet
	post: result = self.clientDependency->select(d:Dependency | d.oclIsKindOf(Binding))->collect(b | b.oclAsType(Binding).argument)->asSet

context ModelElement
-- Tags associated with a ModelElement (directly via a property list or indirectly via a Stereotype) must not clash with any metaattributes associated with the Model Element.
--not specified in OCL
inv: true

context ModelElement
-- A model element must have at most one tagged value with a given tag name.
inv: self.taggedValue->forAll(t1, t2 : TaggedValue | \
					t1.tag = t2.tag implies t1 = t2)

context ModelElement
-- (Required tags because of stereotypes) If T in modelElement.stereotype.require Tag.such that T.value = unspecified, then the modelElement must have a tagged value with name = T.name.
inv: self.stereotype.requiredTag->forAll(tag | \
			tag.value->isEmpty implies \
					self.taggedValue->exists(t | \
						t.tag = tag.tag))

context Namespace
	-- if a contained element, which is not an Association or Generalization has a name, then the name must be unique in the Namespace.
	inv: self.allContents->forAll(me1, me2 : ModelElement | \
				      (not me1.oclIsKindOf(Association) and not me2.oclIsKindOf(Association) and \
				      me2.name = me1.name) implies \
				      me1 = me2)

context Namespace
	-- all Associations must have a unique combination of name and associated Classifiers in the Namespace.
	inv: self.allContents->select(e | e.oclIsKindOf(Association))-> \
	     forAll(a1, a2 | \
			a1.name = a2.name and \
			a1.oclAsType(Association).connection.type = a2.oclAsType(Association).connection.type \
			implies a1 = a2)

context Namespace::contents:Set(ModelElement)
	-- the operation contents results in a Set containing all ModelElements contained by the Namespace.
	asl: self.ownedElement->union(self.namespace.contents)
	post: result = self.ownedElement->union(self.namespace.contents)

context Namespace::allContents:Set(ModelElement)
	-- the operation allContents results in a Set containing all ModelElements contained by the Namespace.
	asl: self.contents
	post: result = self.contents

context Namespace::allVisibleElements:Set(ModelElement)
	-- the operation allVisibleElements results in a Set containing all ModelElements visible outside of the Namespace.
	asl: self.allContents->select(e | \
		     e.elementOwnership.visibility = #public)
	post: result = self.allContents->select(e | \
		     e.elementOwnership.visibility = #public)

context Namespace::allSurroundingNamespaces:Set(Namespace)
	-- the operation allSurroundingNamespaces results in a Set containing all surrounding Namespaces.
	asl: self.namespace.allSurroundingNamespaces->including(self.namespace)
	post: result = self.namespace.allSurroundingNamespaces->including(self.namespace)

context NodeInstance
-- [1] A NodeInstance must have only one Classifier as its origin, and it must be a Node.
inv: self.classifier->forAll ( c | c.oclIsKindOf(Node)) \
					and \
					self.classifier->size = 1

context NodeInstance
-- [2] Each ComponentInstance that resides on a NodeInstance must be an instance of a Component that resides on the corresponding Node.
inv: self.resident->forAll(n | \
			self.classifier.oclAsType(Node).resident->includes(n.classifier))

context Object
-- [1] Each of the Classifiers must be a kind of Class.
inv: self.classifier->forAll ( c | c.oclIsKindOf(Class))

context ObjectFlowState
-- [1] Parameters of an object flow state must have a type and direction compatible with classifier or classifier-in-state of the object flow state.
inv: let osftype : Classifier = \
	(if self.type.oclIsKindOf(ClassifierInState) \
	then self.type.type else self.type) in \
	self.parameter.forAll( \
		type = osftype \
		or (parameter.kind = #in \
		and osftype.allSupertypes->includes(type)) \
		or ((parameter.kind = #out or parameter.kind = #return) \
		and type.allSupertypes->includes(osftype)) \
		or (parameter.kind = #inout \
		and ( osftype.allSupertypes->includes(type) \
		or type.allSupertypes->includes(osftype))))

context ObjectFlowState
-- [2] Downstream states have entry actions that accept input conforming to the type of the classifier or classifier-in-state. The entry actions use the input parameters of the object flow state. Valid downstream states are calculated by traversing outgoing transitions transitively, skipping pseudo states, and entering and exiting subactivitystates, looking for regular states. If the object flow state has no parameters, then the target of downstream actions must conform to the type of the classifier or classifier-in-state.
inv: self.allnextleafstates.size > 0 and \
		self.allnextleafstates.forAll(self.isinputaction(entry))

context ObjectFlowState
-- [3] Upstream states have entry actions that provide output or return values conforming to the type of the classifier or classifier-in-state. The entry actions use the output or return parameters of the object flow state. Valid upstream states are calculated by traversing incoming transitions transitively, skipping pseudo states, entering and exiting subactivity states, looking for regular states.
inv: self.allnextleafstates.forAll(self.allpreviousleaf \
		states.size > 0 and \
		self.allpreviousleafstates.forAll(self.isoutputaction(entry))

context Package
-- [1] A Package may only own or reference Packages, Classifiers, Associations, Generalizations, Dependencies, Constraints, Collaborations, StateMachines, and Stereotypes.
inv: self.contents->forAll ( c | \
				c.oclIsKindOf(Package) or \
				c.oclIsKindOf(Classifier) or \
				c.oclIsKindOf(Association) or \
				c.oclIsKindOf(Generalization) or \
				c.oclIsKindOf(Dependency) or \
				c.oclIsKindOf(Constraint) or \
				c.oclIsKindOf(Collaboration) or \
				c.oclIsKindOf(StateMachine) or \
				c.oclIsKindOf(Stereotype) )

context Package
-- [2] No imported element (excluding Association) may have the same name or alias as any element owned by the Package or one of its supertypes.
inv: self.allImportedElements->reject( re | \
		re.oclIsKindOf(Association) )->forAll( re | \
		(re.elementImport.alias <> '' implies \
		not (self.allContents - self.allImportedElements)-> \
		reject( ve | \
			ve.oclIsKindOf (Association) )->exists ( ve | \
			ve.name = re.elementImport.alias)) \
		and \
		(re.elementImport.alias = '' implies \
		not (self.allContents - self.allImportedElements)-> \
			reject ( ve | \
			ve.oclIsKindOf (Association) )->exists ( ve | \
			ve.name = re.name) ) )

context Package
-- [3] Imported elements (excluding Association) may not have the same name or alias.
inv: self.allImportedElements->reject( re | \
		not re.oclIsKindOf (Association) )->forAll( r1, r2 | \
		(r1.elementImport.alias <> '' and \
		r2.elementImport.alias <> '' and \
		r1.elementImport.alias = r2.elementImport.alias \
		implies r1 = r2) \
			and \
		(r1.elementImport.alias = '' and \
		r2.elementImport.alias = '' and \
		r1.name = r2.name implies r1 = r2) \
			and \
		(r1.elementImport.alias <> '' and \
		r2.elementImport.alias = '' implies \
		r1.elementImport.alias <> r2.name))

context Package
-- [4] No imported element (Association) may have the same name or alias combined with the same set of associated Classifiers as any Association owned by the Package or one of its supertypes.
inv: self.allImportedElements->select( re | \
		re.oclIsKindOf(Association) )->forAll( re | \
		(re.elementImport.alias <> '' implies \
		not (self.allContents - self.allImportedElements)-> \
		select( ve | \
			ve.oclIsKindOf(Association) )->exists( \
			me : ModelElement | let ve : Association = me.oclAsType(Association) in \
			ve.name = re.elementImport.alias \
			and \
		ve.connection->size = re.connection->size and \
		Sequence {1..re.connection->size}->forAll( i | \
			re.connection->at(i).type = \
			ve.connection->at(i).type ) ) ) \
			and \
			(re.elementImport.alias = '' implies \
			not (self.allContents - self.allImportedElements)-> \
			select( ve | \
			not ve.oclIsKindOf(Association) )->exists( ve : \
			Association | \
			ve.name = re.name \
			and \
			ve.connection->size = re.connection->size and \
			Sequence {1..re.connection->size}->forAll( i | \
				re.connection->at(i).type = \
				ve.connection->at(i).type ) ) ) )

context Package
-- [5] Imported elements (Association) may not have the same name or alias combined with the same set of associated Classifiers.
inv: self.allImportedElements->select ( re | \
	re.oclIsKindOf (Association) )->forAll ( m1, m2 : ModelElement | \
	let r1 = m1.oclAsType(Association) in \
	let r2 = m2.oclAsType(Association) in \
	(r1.connection->size = r2.connection->size and \
	Sequence {1..r1.connection->size}->forAll ( i | \
	r1.connection->at (i).type = \
	r2.connection->at (i).type and \
	r1.elementImport.alias <> '' and \
	r2.elementImport.alias <> '' and \
	r1.elementImport.alias = r2.elementImport.alias \
	implies r1 = r2)) \
		and \
	(r1.connection->size = r2.connection->size and \
	Sequence {1..r1.connection->size}->forAll ( i | \
	r1.connection->at (i).type = \
	r2.connection->at (i).type and \
	r1.elementImport.alias = '' and \
	r2.elementImport.alias = '' and \
	r1.name = r2.name \
	implies r1 = r2)) \
		and \
	(r1.connection->size = r2.connection->size and \
	Sequence {1..r1.connection->size}->forAll ( i | \
	r1.connection->at (i).type = \
	r2.connection->at (i).type and \
	r1.elementImport.alias <> '' and \
	r2.elementImport.alias = '' \
	implies r1.elementImport.alias <> r2.name)))

context Package::contents:Set(ModelElement)
-- [1] The operation contents results in a Set containing the ModelElements owned by or imported by the Package.
post: result = self.ownedElement->union(self.importedElement)

context Package::allImportedElements:Set(ModelElement)
-- [2] The operation allImportedElements results in a Set containing the Model Elements imported by the Package or one of its supertypes.
post: result = self.importedElement->union( \
	self.parent->collect(g | g.oclAsType(Package).allImportedElements->select(re | \
		re.elementImport.visibility = #public or \
		re.elementImport.visibility = #protected)))

context Package::allContents:Set(ModelElement)
-- [3] The operation allContents results in a Set containing the ModelElements owned by or imported by the Package or one of its ancestors.
post: result = self.contents->union( \
	self.parent->collect(g | g.oclAsType(Package).allContents->select(e | \
		e.elementOwnership.visibility = #public or \
		e.elementOwnership.visibility = #protected)))

context Pseudostate
-- [1] An initial vertex can have at most one outgoing transition and no incoming transitions.
inv: (self.kind = #initial) implies \
	((self.outgoing->size <= 1) and (self.incoming->isEmpty))

context Pseudostate
-- [2] History vertices can have at most one outgoing transition.
inv: ((self.kind = #deepHistory) or (self.kind = #shallowHistory)) \
	implies \
	(self.outgoing->size <= 1)

context Pseudostate
-- [3] A join vertex must have at least two incoming transitions and exactly one outgoing transition.
inv: (self.kind = #join) implies \
	((self.outgoing->size = 1) and (self.incoming->size >= 2))

context Pseudostate
-- [4] A fork vertex must have at least two outgoing transitions and exactly one incoming transition.
inv: (self.kind = #fork) implies \
	((self.incoming->size = 1) and (self.outgoing->size >= 2))

context Pseudostate
-- [5] A junction vertex must have at least one incoming and one outgoing transition.
inv: (self.kind = #junction) implies \
	((self.incoming->size >= 1) and (self.outgoing->size >= 1))

context Pseudostate
-- [6] A choice vertex must have at least one incoming and one outgoing transition.
inv: (self.kind = #choice) implies \
	((self.incoming->size >= 1) and (self.outgoing->size >= 1))

context Pseudostate
-- [1] In activity graphs, transitions incoming to (and outgoing from) join and fork pseudostates have as sources (targets) any state vertex. That is, joins and forks are syntactically not restricted to be used in combination with composite states, as is the case in state machines.
inv: self.stateMachine.oclIsTypeOf(ActivityGraph) implies \
	((self.kind = #join or self.kind = #fork) implies \
	(self.incoming->forAll(source.oclIsKindOf(State) or \
	source.oclIsTypeOf(Pseudostate)) and \
	(self.outgoing->forAll(source.oclIsKindOf(State) or \
	source.oclIsTypeOf(Pseudostate)))))

context Pseudostate
-- [2] All of the paths leaving a fork must eventually merge in a subsequent join in the model. Furthermore, multiple layers of forks and joins must be well nested, with the exception of forks and joins leading to or from synch state. Therefore the concurrency structure of an activity graph is in fact equally restrictive as that of an ordinary state machine, even though the composite states need not be explicit.
inv: true

context Reception
-- [1] A Reception can not be a query.
inv: not self.isQuery

context SendAction
-- [1] The number of arguments is the same as the number of parameters of the Signal.
inv: self.actualArgument->size=self.signal.allAttributes->size

context SendAction
-- [2] A Signal is always asynchronous.
inv: self.isAsynchronous

context StateMachine
-- [1] A StateMachine is aggregated within either a classifier or a behavioral feature.
inv: self.context.oclIsKindOf(BehavioralFeature) or \
		self.context.oclIsKindOf(Classifier)

context StateMachine
-- [2] A top state is always a composite.
inv: self.top.oclIsTypeOf(CompositeState)

context StateMachine
-- [3] A top state cannot have any containing states.
inv: self.top.container->isEmpty

context StateMachine
-- [4] The top state cannot be the source of a transition.
inv: (self.top.outgoing->isEmpty)

context StateMachine
-- [5] If a StateMachine describes a behavioral feature, it contains no triggers of type CallEvent, apart from the trigger on the initial transition (see OCL for Transition [8]).
inv: self.context.oclIsKindOf(BehavioralFeature) implies \
	self.transitions->reject( t |\
		t.source.oclIsKindOf(Pseudostate) and \
		t.source.oclAsType(Pseudostate).kind= #initial).trigger->isEmpty

context Stereotype
-- Stereotype names must not clash with any baseClass names.
inv: Stereotype.allInstances->forAll(st | \
					st.baseClass <>self.name)
context Stereotype
-- Stereotype names must not clash with the names of any inherited Stereotype.
inv: self.allParents->forAll(st | \
				st.name <> self.name)

context Stereotype
-- Stereotype names must not clash in the (M2) meta-class namespace, nor with the names of any inherited Stereotype, nor with any baseClass names.
--M2 level not accessible
inv: true

context Stereotype
-- The baseClass name must be provided; icon is optional and is specified in an implementation specific way.
inv: self.baseClass <> ''

context Stereotype
-- [5] Tag names attached to a Stereotype must not clash with M2 meta-attribute namespace of the appropriate baseClass element, nor with Tag names of any inherited Stereotype.
-- M2 level not accessible
inv: true

context Stimulus
-- [1] The number of arguments must match the number of Arguments of the Action.
inv: self.dispatchAction.actualArgument->size = self.argument->size

-- [2] The Action must be a SendAction, a CallAction, a CreateAction, or a DestroyAction.
inv: self.dispatchAction.oclIsKindOf (SendAction) \
	or self.dispatchAction.oclIsKindOf (CallAction) \
	or self.dispatchAction.oclIsKindOf (CreateAction) \
	or self.dispatchAction.oclIsKindOf (DestroyAction)

context SubactivityState
-- [1] A subactivity state is a submachine state that is linked to an activity graph.
inv: self.submachine.oclIsKindOf(ActivityGraph)

context SubmachineState
-- [1] Only stub states allowed as substates of a submachine state.
inv: self.subvertex->forAll (s | s.oclIsTypeOf(StubState))

context SubmachineState
-- [2] Submachine states are never concurrent.
inv: self.isConcurrent = false

context Subsystem
-- [1] For each Operation in an Interface offered by a Subsystem, the Subsystem itself or at least one contained specification element must have a matching Operation.
inv: self.specification.allOperations->forAll(interOp | \
		self.allOperations->union \
		(self.allSpecificationElements->select(specEl| \
		specEl.oclIsKindOf(Classifier))->forAll(c| \
		c.oclAsType(Classifier).allOperations))->exists \
		( op | op.hasSameSignature(interOp) ) )

context Subsystem
-- [2] The Features of a Subsystem may only be Operations or Receptions.
inv: self.feature->forAll(f | f.oclIsKindOf(Operation) or \
			f.oclIsKindOf(Reception))

context Subsystem::allSpecificationElements:Set(ModelElement)
-- [1] The operation allSpecificationElements results in a Set containing the Model Elements specifying the behavior of the Subsystem.
post: result = self.allContents->select(c | \
				c.elementOwnership.isSpecification )

context Subsystem
-- [2] The operation contents results in a Set containing the ModelElements owned by or imported by the Subsystem.
post: result = self.ownedElement->union(self.importedElement)

context SynchState
-- [1] The value of the bound attribute must be a positive integer, or unlimited.
inv: (self.bound > 0) or (self.bound = unlimited)

context SynchState
-- [2] All incoming transitions to a SynchState must come from the same region and all outgoing transitions from a SynchState must go to the same region.
inv: true

context TerminateAction
-- [1] A TerminateAction has no arguments.
inv: self.actualArgument->size = 0

context TerminateAction
-- [2] A TerminateAction has no target expression.
inv: self.target->isEmpty

context Transition
-- [1] A fork segment should not have guards or triggers.
inv: self.source.oclIsKindOf(Pseudostate) implies \
	((self.source.oclAsType(Pseudostate).kind = #fork) implies \
	((self.guard->isEmpty) and (self.trigger->isEmpty)))

context Transition
-- [2] A join segment should not have guards or triggers.
inv: self.target.oclIsKindOf(Pseudostate) implies \
	((self.target.oclAsType(Pseudostate).kind = #join) implies \
	((self.guard->isEmpty) and (self.trigger->isEmpty)))

context Transition
-- [3] A fork segment should always target a state.
inv: (self.stateMachine->notEmpty) implies \
	self.source.oclIsKindOf(Pseudostate) implies \
	((self.source.oclAsType(Pseudostate).kind = #fork) implies \
	(self.target.oclIsKindOf(State)))

context Transition
-- [4] A join segment should always originate from a state.
inv: (self.stateMachine->notEmpty) implies \
	self.target.oclIsKindOf(Pseudostate) implies \
	((self.target.oclAsType(Pseudostate).kind = #join) implies \
	(self.source.oclIsKindOf(State)))

context Transition
-- [5] Transitions outgoing pseudostates may not have a trigger.
inv: self.source.oclIsKindOf(Pseudostate) \
		implies (self.trigger->isEmpty))

context Transition
-- [6] Join segments should originate from orthogonal states.
inv: self.target.oclIsKindOf(Pseudostate) implies \
	((self.target.oclAsType(Pseudostate).kind = #join) implies \
	(self.source.container.isConcurrent))

context Transition
-- [7] Fork segments should target orthogonal states.
inv: self.source.oclIsKindOf(Pseudostate) implies \
	((self.source.oclAsType(Pseudostate).kind = #fork) implies \
		(self.target.container.isConcurrent))

context Transition
-- [8] An initial transition at the topmost level may have a trigger with the stereotype "create." An initial transition of a StateMachine modeling a behavioral feature has a CallEvent trigger associated with that BehavioralFeature. Apart from these cases, an initial transition never has a trigger.
inv: self.source.oclIsKindOf(Pseudostate) implies \
	((self.source.oclAsType(Pseudostate).kind = #initial) implies \
	(self.trigger->isEmpty or \
	((self.source.container = self.stateMachine.top) and \
	(self.trigger.stereotype.name = 'create')) or \
	(self.stateMachine.context.oclIsKindOf(BehavioralFeature) \
	and \
	self.trigger.oclIsKindOf(CallEvent) and \
	(self.trigger.oclAsType(CallEvent).operation = \
	self.stateMachine.context)) \
	))

context Transition
-- see [8]
inv: self.source.oclIsKindOf(Pseudostate) implies \
	((self.source.oclAsType(Pseudostate).kind = #initial) implies \
	(self.trigger->isEmpty or \
	((self.source.container = self.stateMachine.top) and \
	(self.trigger.stereotype.name = 'create')) or \
	(self.StateMachine.context.oclIsKindOf(BehaviouralFeature) \
		and \
	self.trigger.oclIsKindOf(CallEvent) and \
	(self.trigger.operation = \
	self.stateMachine.context)) \
	))

context UseCase
-- [1] UseCases can only have binary Associations.
inv: self.associations->forAll(a | a.connection->size = 2)

context UseCase
-- [2] UseCases can not have Associations to UseCases specifying the same entity.
inv: self.associations->forAll(a | \
		a.allConnections->forAll(s, o| \
		let s_uc : UseCase = s.type.oclAsType(UseCase) in \
		let o_uc : UseCase = o.type.oclAsType(UseCase) in \
		(s_uc.specificationPath->isEmpty and \
		o_uc.specificationPath->isEmpty ) \
			or \
		(not s_uc.specificationPath->includesAll( \
		o_uc.specificationPath) and \
		not o_uc.specificationPath->includesAll( \
		s_uc.specificationPath)) \
		))

context UseCase
-- [3] A UseCase cannot contain any Classifiers.
inv: self.contents->isEmpty

context UseCase
-- [4] The names of the ExtensionPoints must be unique within the UseCase.
inv: self.allExtensionPoints -> forAll (x, y | \
				x.name = y.name implies x = y )

context UseCase::specificationPath:Set(Namespace)
-- [1] The operation specificationPath results in a set containing all surrounding Namespaces that are not instances of Package.
post: result = self.allSurroundingNamespaces->select(n | \
		n.oclIsKindOf(Subsystem) or n.oclIsKindOf(Class))

context UseCase::allExtensionPoints:Set(ExtensionPoint)
-- [2] The operation allExtensionPoints results in a set containing all ExtensionPoints of the UseCase.
post: result = self.allParents->collect(ep | ep.oclAsType(ExtensionPoint).extensionPoint) -> union (self.extensionPoint)

context UseCaseInstance
-- [1] The Classifier of a UseCaseInstance must be a UseCase.
inv: self.classifier->forAll ( c | c.oclIsKindOf (UseCase) )


